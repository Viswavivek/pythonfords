1) if / elif / else (including ternary)
	1.	Write a function is_leap(year) that returns True if year is a leap year (Gregorian rules).
	2.	Given three numbers, return the largest without using built-in max().
	3.	Implement grade_letter(score) that returns 'A'/'B'/'C'/'D'/'F' for numeric score with typical cutoffs and validation for 0–100.
	4.	Write classify_triangle(a,b,c) that returns 'equilateral'/'isosceles'/'scalene'/'invalid'.
	5.	fizzbuzz(n): for 1..n print Fizz/Buzz/FizzBuzz/number using conditional logic.
	6.	Given a string, return whether it’s a valid variable name (letters/underscore start, only alnum+underscore afterwards).
	7.	Implement closest_to_zero(nums) that returns the number closest to zero; tie-breaker returns positive.
	8.	salary_tax(salary) compute tax using piecewise brackets (design 3 brackets) and return net salary.
	9.	Given date (d,m,y), check if the date is valid (consider months length and leap years).
	10.	Write a function that returns "even", "odd", or "zero" for an integer using a single-line ternary expression (or chained ternary).

2) for loops (iteration over sequences / ranges)
	1.	Sum all even numbers in a list without using sum() or comprehensions.
	2.	Count occurrences of a character in a string (case-sensitive) using for.
	3.	Given a list of strings, return a new list with strings reversed (preserve original).
	4.	Implement flatten(matrix) that flattens a 2D list into 1D using nested for loops.
	5.	Print multiplication table (1..10) in a formatted grid.
	6.	Given a list of integers, move all zeros to the end while preserving order of non-zero items (in-place).
	7.	Given two lists of equal length, compute their dot product.
	8.	Implement a simple run-length encoder that outputs [(char,count), ...] from a string.
	9.	From a list of filenames, print only those with extension .py (case-insensitive).
	10.	Implement prime_factors(n) that returns prime factors as a list using trial division.

3) while loops
	1.	Implement factorial using a while loop.
	2.	Generate Fibonacci numbers up to a given max value using while.
	3.	Implement integer division divmod_emulate(a,b) returning (q,r) using repeated subtraction (handle negatives).
	4.	Prompt (simulate) user input loop until they enter "quit" — collect and return all previous inputs (function signature: def collect(inputs) where inputs is a list to simulate user entries).
	5.	find_cycle_start(sequence_generator) — given a generator that yields ints and eventually repeats, detect first repeated value (use set + while).
	6.	Reverse a singly linked list implemented as node objects using while.
	7.	Implement sqrt_int(n) that returns floor(sqrt(n)) using binary search implemented with while.
	8.	Simulate the Collatz sequence for a starting integer and return the length until it reaches 1.
	9.	Implement a progressive backoff retry simulator: attempt up to max_attempts and double delay each failure — return attempts used. (use while to model attempts)
	10.	Given an integer n, repeatedly sum its digits until the result is a single digit; return that digital root.


4) match / structural pattern matching (Python 3.10+)
	1.	Write describe_point(obj) that uses match to return 'origin', 'on x', 'on y', or 'quadrant' for (x,y) tuples.
	2.	Parse simple commands like ("move", x, y) or ("quit",) using match and return structured results.
	3.	Use match to extract named fields from a dict-like mapping {"type":"circle","r":...} and compute area.
	4.	Given nested lists, use match to detect pattern [a, [b, c]] and return a,b,c or None.
	5.	Implement an AST evaluator using match over nodes like ("add", left, right) / ("num", value).
	6.	Use match to validate version strings like ("v", major:int, minor:int) and return tuple (major,minor).
	7.	Match on objects with attributes (use case Point(x=x, y=y)) to compute distance from origin.
	8.	Given a list of shapes, use match to count how many are circles (dicts with type=='circle').
	9.	Implement flatten_once(item) that uses match to flatten one level if item is a list or tuple, otherwise return [item].
	10.	Use match to implement router dispatch where patterns include a path string split into segments, e.g. ["users", id] → return user handler with id.
